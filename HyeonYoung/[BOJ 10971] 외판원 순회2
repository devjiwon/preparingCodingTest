#include <stdio.h>
#define MAXN (10 + 5)

int N; // 도시의 수
int arr[MAXN][MAXN]; // 각 도시간에 이동하는데 드는 비용 행렬(갈 수 없는 경우 : 0)
int perm[MAXN]; // 순열(도시 ABCD, ABDC, ACBD, ACDB ...)

int next_permutation(int* arr)
{
    /* ex) 7 2 3 6 5 4 1의 다음 순열을 구하는 과정 -> 답은 7 2 4 1 3 5 6 */


    /*
        1) 끝에서부터 탐색하면서 내림차순 정렬에 위배되는 숫자 찾기 (7 2 "3" 6 > 5 > 4 > 1)
        - i는 마지막 요소의 인덱스, 6로 초기화
        - 뒤 -> 앞으로 숫자를 땡기면서(i--) 이전 숫자 > 현재 숫자가 성립하는지 따져봄
        - 마지막 순열일 경우(if문), 0을 리턴하여 계산 과정(calculate)을 끝내도록 함
        - while문을 빠져나오는 순간 i = 3임
    */
    int i = N - 1;
    while (i > 0 && arr[i - 1] > arr[i]) {
        i--;

        if (i <= 0) return 0;
    }

    /*
        2) 바꿀 숫자 찾아내기
        - 구한 i값을 가지고 우리가 궁금한 것은 arr[i - 1] 즉, 숫자 3임
        - 이후 3뒤의 수열(6 5 4 1)에서, 3보다 큰 것 중 가장 작은 수인 4를 찾아내야 함
        - 위를 코드 상으로 구현할 땐, 숫자 3보다 작지 않은 최초의 수
    */
    int j = N - 1;
    while (arr[i - 1] >= arr[j]) {
        j--;
    }

    /*
        3) 숫자 바꾸기
        - swap(3, 4)
        - 결과적으로 배열은 7 2 4 6 5 3 1 이렇게 될 것임
    */
    int tmp = arr[i - 1];
    arr[i - 1] = arr[j];
    arr[j] = tmp;

    /*
        4) 뒷 부분 재정렬
        - 배열 7 2 4 6 5 3 1 에서 7 2 4 까지는 잘 맞게 된 거고,
        - 이제 6 5 3 1 이부분을 오름차순으로 다시 정렬해줌
        - 현재 i = 3이고, j = 6으로 초기화
        - while문 돌면서 제일 작은 수 <-> 제일 큰 수 바꾸고 양쪽에서 한 단계씩 앞으로
    */
    j = N - 1;
    while (i < j)
    {
        tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;

        i++;
        j--;
    }

    return 1;
}
int main()
{
    scanf("%d", &N);
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
            scanf("%d", &arr[i][j]);

    // 도시를 순회하는 순열을 저장
    for (int i = 0; i < N; i++)
        perm[i] = i;

    int min = 987654321;
    do {
        scanf("%d", &N);
        for (int i = 0; i < N; i++)
            for (int j = 0; j < N; j++)
                scanf("%d", &arr[i][j]);

        int OK = 1; // 갈 수 있는 길 = 1
        int sum = 0;

        for (int i = 0; i < N - 1; i++)
        {
            if (arr[perm[i]][perm[i + 1]] == 0) // 갈 수 없는 길
                OK = 0;
            else // 갈 수 있는 길이라면
                sum += arr[perm[i]][perm[i + 1]]; // 비용을 더해줌
        }
        if (OK == 1 && arr[perm[N - 1]][perm[0]] != 0)
        {
            sum += arr[perm[N - 1]][perm[0]];

            if (min > sum) min = sum;
        }

    } while (next_permutation(perm)); // 모든 경우의 수마다 반복

    printf("%d\n", min);
    return 0;
}
