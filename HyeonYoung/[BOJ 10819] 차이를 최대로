#if 0 // * Sol 1) DFS로 구현

#include <stdio.h>
#include <stdlib.h>
#define MAXN (8 + 2)

int N;
int arr[MAXN]; // 문제에서 주어진 정수 배열
int perm[MAXN]; // 순열(012345, 012354, 012435, 012453 ..)
int chk[MAXN];
int max;
void DFS(int depth)
{
    if (depth == N)
    {
        int sum = 0;

        for (int i = 0; i < N - 1; i++)
            sum += abs(arr[perm[i]] - arr[perm[i + 1]]);
        
        if (max < sum) max = sum;
    }

    for (int idx = 0; idx < N; idx++)
    {
        if (chk[idx] == 1) continue; // 이미 방문했다면 skip

        chk[idx] = 1; // 방문 체크

        perm[depth] = idx;
        /* 
            <- 이거 대신 perm[depth] = arr[idx];
            이렇게 쓰고 마지막에 perm[i] - perm[i + 1] 한 것과 동일
        */
        DFS(depth + 1);
            
        chk[idx] = 0; // 원상 복귀
    }
}
int main(void)
{
    scanf("%d", &N);
    for (int i = 0; i < N; i++)
        scanf("%d", &arr[i]);

    DFS(0);
    printf("%d", max);

    return 0;
}

#endif

#if 01 // * Sol 2) 순열로 구현 ==> But, 시간초과!

#include <stdio.h>
#include <stdlib.h>
#define MAXN (8 + 2)

int N;
int arr[MAXN]; // 문제에서 주어진 정수 배열

int comp(const void* a, const void* b)
{
    int num1 = *(int*)a;
    int num2 = *(int*)b;
    return num1 - num2;
}
int next_permutation(int* arr)
{
    /* ex) 7 2 3 6 5 4 1의 다음 순열을 구하는 과정 -> 답은 7 2 4 1 3 5 6 */
    

    /*
        1) 끝에서부터 탐색하면서 내림차순 정렬에 위배되는 숫자 찾기 (7 2 "3" 6 > 5 > 4 > 1)
        - i는 마지막 요소의 인덱스, 6로 초기화
        - 뒤 -> 앞으로 숫자를 땡기면서(i--) 이전 숫자 > 현재 숫자가 성립하는지 따져봄
        - 마지막 순열일 경우(if문), 0을 리턴하여 계산 과정(calculate)을 끝내도록 함
        - while문을 빠져나오는 순간 i = 3임
    */
    int i = N - 1;
    while (i > 0 && arr[i - 1] > arr[i]) {
        i--;

        if (i <= 0) return 0;
    }

    /*
        2) 바꿀 숫자 찾아내기
        - 구한 i값을 가지고 우리가 궁금한 것은 arr[i - 1] 즉, 숫자 3임
        - 이후 3뒤의 수열(6 5 4 1)에서, 3보다 큰 것 중 가장 작은 수인 4를 찾아내야 함
        - 위를 코드 상으로 구현할 땐, 숫자 3보다 작지 않은 최초의 수
    */
    int j = N - 1;
    while (arr[i - 1] >= arr[j]) {
        j--;
    }

    /* 
        3) 숫자 바꾸기
        - swap(3, 4)
        - 결과적으로 배열은 7 2 4 6 5 3 1 이렇게 될 것임
    */
    int tmp = arr[i - 1];
    arr[i - 1] = arr[j];
    arr[j] = tmp;

    /*
        4) 뒷 부분 재정렬
        - 배열 7 2 4 6 5 3 1 에서 7 2 4 까지는 잘 맞게 된 거고,
        - 이제 6 5 3 1 이부분을 오름차순으로 다시 정렬해줌
        - 현재 i = 3이고, j = 6으로 초기화
        - while문 돌면서 제일 작은 수 <-> 제일 큰 수 바꾸고 양쪽에서 한 단계씩 앞으로
    */
    j = N - 1;
    while (i < j)
    {
        tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;

        i++;
        j--;
    }

    return 1;
}
int calculate(int* a)
{
    int sum = 0;

    for (int i = 1; i < N; i++)
        sum += abs(arr[i] - arr[i - 1]);

    return sum;
}
int main(void)
{
    scanf("%d", &N);
    for (int i = 0; i < N; i++)
        scanf("%d", &arr[i]);

    qsort(arr, N, sizeof(int), comp);

    int ans = 0;
    do {
        int tmp = calculate(arr);
        
        if (ans < tmp) ans = tmp;
    } while (next_permutation(arr));

    printf("%d", ans);

    return 0;
}

#endif
